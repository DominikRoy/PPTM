(*Dolev-Yao model Open Channel*)
(*Channel between UAV A and UAV B*)
free c:channel.


(* RSA modulus *)
type N.

(* The attacker should not have knowledge of the actual identifier of the capsule mapped from  f (see paper Sec.4.2 step (4)) (secret).
Although, we define the secret as "weak" to check if offline brute-force or dictionary attacks are feasible. *)

free dAi: bitstring [private].
weaksecret dAi.
free dBik: bitstring [private].
weaksecret dBik.


(* Types, Constants and Variables *)
type radius.
type length.
type angle.
type origin.
type nonce.
type vector.
type index.




(* A formal query, specifying the attacker can't ever be leaked the
actual capsule identifiers during the protocol. *)
query attacker(dAi).
query attacker(dBik).

(*Verify the non interference property for the capsule identifiers A and B, which means that 
the different secrets are indistingishuable for the adversary strong secrecy.*)
noninterf dBik.
noninterf dAi.

(*Auxiliary Functions*)
fun hash(bitstring):bitstring.
fun map(bitstring):bitstring.(*secure function of 2H(x)+1*)
fun append(bitstring,bitstring):bitstring.
fun mod(bitstring,N):bitstring.
fun exp_mod(bitstring,bitstring,N):bitstring.
fun inv_mod(bitstring,N):bitstring.
fun extract_elem(vector,index):bitstring.
fun add_elem(vector,bitstring,index):vector.
fun map_trajectory(origin,angle,radius,length):vector.
(* Type converter *)
fun nonce_to_bitstring(nonce): bitstring [data,typeConverter].
(*Events*)
event end_UAV_A(vector).
event end_UAV_B(bitstring).



(* The process for UAV A*)
let uavA(nB:N) =
    (* Step (3) of Sec.4.2 in our paper*)
    new Oi:origin;
    new Ti:angle;
    new ri:radius;
    new hi:length;
    new xii:nonce;

    (* Step (6) of Sec.4.2, Eq.9*)
    let cAi = exp_mod(nonce_to_bitstring(xii), dAi, nB) in
    (* Step (7) of Sec.4.2*)
    out (c,(cAi,Oi,Ti,ri,hi));
    (* Step (11) of Sec.4.2*)
    in (c, cBi:vector);
    new k:index;
    let cBik = extract_elem(cBi,k) in
    (* Step (12) of Sec.4.2, Eq. 12*)
    let wAik = hash(mod(nonce_to_bitstring(xii),nB)) in 
    (* Step (15) of Sec.4.2*)
    if wAik = cBik then ( 
        (* Step (13) of Sec.4.2, Eq. 14*)
        let wAi = hash(mod(append(nonce_to_bitstring(xii),dAi),nB)) in
        (* Step (16) of Sec.4.2 ==> paper*)
        out(c,wAi);
    
        event end_UAV_A(cBi)).








(* The process for UAV B*)
let uavB(nB:N) =
    (* Step (8) of Sec.4.2*)
    in(c, (cAi:bitstring,Oi:origin,Ti:angle,ri:radius,hi:length));
    let GBi = map_trajectory(Oi,Ti,ri,hi) in
    new k:index;
    (* Step (9) of Sec.4.2*)
    let eBik = inv_mod(dBik,nB) in
    (* Step (10) of Sec.4.2, Eq. 10*)
    let x = exp_mod(cAi,eBik,nB) in
    (* Step (10) of Sec.4.2, Eq. 11*)
    let cBik = hash(x) in
    new cBi:vector;
    let cBi = add_elem(cBi,cBik,k) in
    (* Step (11) of Sec.4.2*)
    out (c, cBi);
    (* Step (16) of Sec.4.2*)
    in (c, wAi:bitstring);
    (* Step (17) of Sec.4.2, Eq. 15*)
    if wAi = hash(mod(append(x,dBik),nB)) then (
        event end_UAV_B(wAi)).

process
    new nB: N;
    ((!uavA(nB)) | (!uavB(nB)))